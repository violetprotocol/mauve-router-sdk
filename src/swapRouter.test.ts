import {
  BigintIsh,
  Currency,
  CurrencyAmount,
  Ether,
  Percent,
  Token,
  TradeType,
  WETH9,
} from '@violetprotocol/mauve-sdk-core'
import {
  encodeRouteToPath,
  encodeSqrtRatioX96,
  FeeAmount,
  nearestUsableTick,
  Pool,
  Route,
  Route as V3Route,
  TickMath,
  TICK_SPACINGS,
  toHex,
  Trade as V3Trade,
} from '@violetprotocol/mauve-v3-sdk'
import JSBI from 'jsbi'
import { SwapRouter, Trade } from '.'

describe('SwapRouter', () => {
  const ETHER = Ether.onChain(1)
  const WETH = WETH9[1]

  const token0 = new Token(1, '0x0000000000000000000000000000000000000001', 18, 't0', 'token0')
  const token1 = new Token(1, '0x0000000000000000000000000000000000000002', 18, 't1', 'token1')

  const feeAmount = FeeAmount.MEDIUM
  const sqrtRatioX96 = encodeSqrtRatioX96(1, 1)
  const liquidity = 1_000_000

  // v3
  const makePool = (token0: Token, token1: Token, liquidity: number) => {
    return new Pool(token0, token1, feeAmount, sqrtRatioX96, liquidity, TickMath.getTickAtSqrtRatio(sqrtRatioX96), [
      {
        index: nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]),
        liquidityNet: liquidity,
        liquidityGross: liquidity,
      },
      {
        index: nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]),
        liquidityNet: -liquidity,
        liquidityGross: liquidity,
      },
    ])
  }

  const pool_0_1 = makePool(token0, token1, liquidity)

  const pool_1_WETH = makePool(token1, WETH, liquidity)

  const slippageTolerance = new Percent(1, 100)
  const recipient = '0x0000000000000000000000000000000000000003'
  const deadline = 123

  describe('#swapCallParameters', () => {
    describe('single-hop exact input (v3)', () => {
      describe('different trade configurations result in identical calldata', () => {
        const expectedCalldata =
          '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000e4472b43f300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000062000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e404e45aaf000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000bb8000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000061000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'

        // 5ae401dc multicall(bytes[], uint256) functionSignature
        // 000000000000000000000000000000000000000000000000000000000000007b
        // 0000000000000000000000000000000000000000000000000000000000000040
        // 0000000000000000000000000000000000000000000000000000000000000002
        // 0000000000000000000000000000000000000000000000000000000000000040
        // 0000000000000000000000000000000000000000000000000000000000000160
        // 00000000000000000000000000000000000000000000000000000000000000e4
        // 472b43f3 functionSignature
        // 0000000000000000000000000000000000000000000000000000000000000064
        // 0000000000000000000000000000000000000000000000000000000000000062
        // 0000000000000000000000000000000000000000000000000000000000000080
        // 0000000000000000000000000000000000000000000000000000000000000003
        // 0000000000000000000000000000000000000000000000000000000000000002
        // 0000000000000000000000000000000000000000000000000000000000000001
        // 0000000000000000000000000000000000000000000000000000000000000002
        // 0000000000000000000000000000000000000000000000000000000000000000
        // 000000000000000000000000000000000000000000000000000000e4
        //
        // 04e45aaf EXACT_INPUT_SINGLE_FUNC_SIG exactInputSingle((address,address,uint24,address,uint256,uint256,uint160))
        // 0000000000000000000000000000000000000000000000000000000000000001
        // 0000000000000000000000000000000000000000000000000000000000000002
        // 0000000000000000000000000000000000000000000000000000000000000bb8
        // 0000000000000000000000000000000000000000000000000000000000000003
        // 0000000000000000000000000000000000000000000000000000000000000064
        // 0000000000000000000000000000000000000000000000000000000000000061
        // 0000000000000000000000000000000000000000000000000000000000000000
        // 00000000000000000000000000000000000000000000000000000000

        const amountIn = CurrencyAmount.fromRawAmount(token0, JSBI.BigInt(100))

        const v3Trade = V3Trade.fromRoute(new V3Route([pool_0_1], token0, token1), amountIn, TradeType.EXACT_INPUT)

        it.only('array of trades', async () => {
          const trades = [await v3Trade]
          const { calls, value } = await SwapRouter.swapCallParameters(trades, {
            slippageTolerance,
            recipient,
            deadlineOrPreviousBlockhash: deadline,
          })

          encodeTrade(
            'exactInput',
            token0,
            token1,
            pool_0_1,
            recipient,
            (await v3Trade).maximumAmountIn(slippageTolerance, (await v3Trade).inputAmount).quotient,
            (await v3Trade).minimumAmountOut(slippageTolerance, (await v3Trade).outputAmount).quotient
          )
          encodeMultiHopTrade(
            TradeType.EXACT_INPUT,
            new V3Route([pool_0_1], token0, token1),
            recipient,
            (await v3Trade).maximumAmountIn(slippageTolerance, (await v3Trade).inputAmount).quotient,
            (await v3Trade).minimumAmountOut(slippageTolerance, (await v3Trade).outputAmount).quotient
          )
          expect(calls).toEqual(expectedCalldata)
          expect(value).toBe('0x00')
        })

        it('meta-trade', async () => {
          const trades = await Trade.fromRoutes(
            [
              {
                routev3: (await v3Trade).swaps[0].route,
                amount: amountIn,
              },
            ],
            TradeType.EXACT_INPUT
          )

          const { calls, value } = await SwapRouter.swapCallParameters(trades, {
            slippageTolerance,
            recipient,
            deadlineOrPreviousBlockhash: deadline,
          })
          expect(calls).toEqual(expectedCalldata)
          expect(value).toBe('0x00')
        })
      })
    })

    describe('single-hop exact output (v2 + v3)', () => {
      describe('different trade configurations result in identical calldata', () => {
        const expectedCalldata =
          '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000e442712a6700000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000066000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e45023b4df000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000bb8000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000067000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
        const amountOut = CurrencyAmount.fromRawAmount(token1, JSBI.BigInt(100))

        const v3Trade = V3Trade.fromRoute(new V3Route([pool_0_1], token0, token1), amountOut, TradeType.EXACT_OUTPUT)

        it('array of trades', async () => {
          const trades = [await v3Trade]
          const { calls, value } = await SwapRouter.swapCallParameters(trades, {
            slippageTolerance,
            recipient,
            deadlineOrPreviousBlockhash: deadline,
          })
          expect(calls).toEqual(expectedCalldata)
          expect(value).toBe('0x00')
        })

        it('meta-trade', async () => {
          const trades = await Trade.fromRoutes(
            [
              {
                routev3: (await v3Trade).swaps[0].route,
                amount: amountOut,
              },
            ],
            TradeType.EXACT_OUTPUT
          )

          const { calls, value } = await SwapRouter.swapCallParameters(trades, {
            slippageTolerance,
            recipient,
            deadlineOrPreviousBlockhash: deadline,
          })
          expect(calls).toEqual(expectedCalldata)
          expect(value).toBe('0x00')
        })
      })
    })

    describe('multi-hop exact input (v2 + v3)', () => {
      describe('different trade configurations result in identical calldata', () => {
        const expectedCalldata =
          '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000104472b43f30000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000006100000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000124b858183f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000005f00000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000001000bb80000000000000000000000000000000000000002000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
        const amountIn = CurrencyAmount.fromRawAmount(token0, JSBI.BigInt(100))

        const v3Trade = V3Trade.fromRoute(
          new V3Route([pool_0_1, pool_1_WETH], token0, WETH),
          amountIn,
          TradeType.EXACT_INPUT
        )

        it('array of trades', async () => {
          const trades = [await v3Trade]
          const { calls, value } = await SwapRouter.swapCallParameters(trades, {
            slippageTolerance,
            recipient,
            deadlineOrPreviousBlockhash: deadline,
          })
          expect(calls).toEqual(expectedCalldata)
          expect(value).toBe('0x00')
        })

        it('meta-trade', async () => {
          const trades = await Trade.fromRoutes(
            [
              {
                routev3: (await v3Trade).swaps[0].route,
                amount: amountIn,
              },
            ],
            TradeType.EXACT_INPUT
          )

          const { calls, value } = await SwapRouter.swapCallParameters(trades, {
            slippageTolerance,
            recipient,
            deadlineOrPreviousBlockhash: deadline,
          })
          expect(calls).toEqual(expectedCalldata)
          expect(value).toBe('0x00')
        })
      })
    })

    describe('multi-hop exact output (v2 + v3)', () => {
      describe('different trade configurations result in identical calldata', () => {
        const expectedCalldata =
          '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000010442712a670000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000006700000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012409b81346000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000690000000000000000000000000000000000000000000000000000000000000042c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb80000000000000000000000000000000000000002000bb8000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
        const amountOut = CurrencyAmount.fromRawAmount(WETH, JSBI.BigInt(100))

        const v3Trade = V3Trade.fromRoute(
          new V3Route([pool_0_1, pool_1_WETH], token0, WETH),
          amountOut,
          TradeType.EXACT_OUTPUT
        )

        it('array of trades', async () => {
          const trades = [await v3Trade]
          const { calls, value } = await SwapRouter.swapCallParameters(trades, {
            slippageTolerance,
            recipient,
            deadlineOrPreviousBlockhash: deadline,
          })
          expect(calls).toEqual(expectedCalldata)
          expect(value).toBe('0x00')
        })

        it('meta-trade', async () => {
          const trades = await Trade.fromRoutes(
            [
              {
                routev3: (await v3Trade).swaps[0].route,
                amount: amountOut,
              },
            ],
            TradeType.EXACT_OUTPUT
          )

          const { calls, value } = await SwapRouter.swapCallParameters(trades, {
            slippageTolerance,
            recipient,
            deadlineOrPreviousBlockhash: deadline,
          })
          expect(calls).toEqual(expectedCalldata)
          expect(value).toBe('0x00')
        })
      })
    })

    describe('Mixed Route', () => {
      describe('single-hop exact input (v2 + v3) backwards compatible', () => {
        describe('different trade configurations result in identical calldata', () => {
          // it('generates the same calldata', async () => {
          //   const trades = [await v3Trade]
          //   const { calls, value } = await SwapRouter.swapCallParameters(trades, {
          //     slippageTolerance,
          //     recipient,
          //     deadlineOrPreviousBlockhash: deadline,
          //   })
          //   expect(calls).toEqual(expectedCalldata)
          //   expect(value).toBe('0x00')
          //   const mixedRouteTrades = [await mixedRouteTrade1, await mixedRouteTrade2]
          //   const { calldata: mixedRouteCalldata, value: mixedRouteValue } = await SwapRouter.swapCallParameters(
          //     mixedRouteTrades,
          //     {
          //       slippageTolerance,
          //       recipient,
          //       deadlineOrPreviousBlockhash: deadline,
          //     }
          //   )
          //   expect(mixedRouteCalldata).toEqual(expectedCalldata)
          //   expect(mixedRouteValue).toBe('0x00')
          // })
          // it('meta-trade', async () => {
          //   const trades = await Trade.fromRoutes(
          //     [
          //       {
          //         routev3: (await v3Trade).swaps[0].route,
          //         amount: amountIn,
          //       },
          //     ],
          //     TradeType.EXACT_INPUT
          //   )
          //   const { calls, value } = await SwapRouter.swapCallParameters(trades, {
          //     slippageTolerance,
          //     recipient,
          //     deadlineOrPreviousBlockhash: deadline,
          //   })
          //   expect(calls).toEqual(expectedCalldata)
          //   expect(value).toBe('0x00')
          //   const mixedRouteTrades = await Trade.fromRoutes([], [], TradeType.EXACT_INPUT, [
          //     {
          //       mixedRoute: (await mixedRouteTrade1).swaps[0].route,
          //       amount: amountIn,
          //     },
          //     {
          //       mixedRoute: (await mixedRouteTrade2).swaps[0].route,
          //       amount: amountIn,
          //     },
          //   ])
          //   const { calldata: mixedRouteCalldata, value: mixedRouteValue } = await SwapRouter.swapCallParameters(
          //     mixedRouteTrades,
          //     {
          //       slippageTolerance,
          //       recipient,
          //       deadlineOrPreviousBlockhash: deadline,
          //     }
          //   )
          //   expect(mixedRouteCalldata).toEqual(expectedCalldata)
          //   expect(mixedRouteValue).toBe('0x00')
          // })
        })
      })

      // describe('multi-hop exact input (mixed route) backwards compatible', () => {
      //   describe('different trade configurations result in identical calldata', () => {
      //     /// calldata verified and taken from existing test
      //     const expectedCalldata =
      //       '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000104472b43f30000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000006100000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000124b858183f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000005f00000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000001000bb80000000000000000000000000000000000000002000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
      //     const amountIn = CurrencyAmount.fromRawAmount(token0, JSBI.BigInt(100))

      //     const mixedRouteTrade1 = MixedRouteTrade.fromRoute(
      //       new MixedRouteSDK([pair_0_1, pair_1_WETH], token0, WETH),
      //       amountIn,
      //       TradeType.EXACT_INPUT
      //     )
      //     const mixedRouteTrade2 = MixedRouteTrade.fromRoute(
      //       new MixedRouteSDK([pool_0_1, pool_1_WETH], token0, WETH),
      //       amountIn,
      //       TradeType.EXACT_INPUT
      //     )

      //     it('single mixedRoute trade', async () => {
      //       const trades = [await mixedRouteTrade1, await mixedRouteTrade2]
      //       const { calls, value } = await SwapRouter.swapCallParameters(trades, {
      //         slippageTolerance,
      //         recipient,
      //         deadlineOrPreviousBlockhash: deadline,
      //       })
      //       expect(calls).toEqual(expectedCalldata)
      //       expect(value).toBe('0x00')
      //     })

      //     it('meta-trade', async () => {
      //       const trades = await Trade.fromRoutes([], [], TradeType.EXACT_INPUT, [
      //         {
      //           mixedRoute: (await mixedRouteTrade1).swaps[0].route,
      //           amount: amountIn,
      //         },
      //         {
      //           mixedRoute: (await mixedRouteTrade2).swaps[0].route,
      //           amount: amountIn,
      //         },
      //       ])

      //       const { calls, value } = await SwapRouter.swapCallParameters(trades, {
      //         slippageTolerance,
      //         recipient,
      //         deadlineOrPreviousBlockhash: deadline,
      //       })
      //       expect(calls).toEqual(expectedCalldata)
      //       expect(value).toBe('0x00')
      //     })
      //   })
      // })

      //   describe('mixed route trades with routes with consecutive pools/pairs', () => {
      //     /// manually verified calldata
      //     const expectedCalldata =
      //       '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004400000000000000000000000000000000000000000000000000000000000000124b858183f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000001000bb80000000000000000000000000000000000000002000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e4472b43f30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005e000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000104472b43f300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000104b858183f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005f000000000000000000000000000000000000000000000000000000000000002b0000000000000000000000000000000000000003000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
      //     const amountIn = CurrencyAmount.fromRawAmount(token0, JSBI.BigInt(100))
      //     const mixedRouteTrade1 = MixedRouteTrade.fromRoute(
      //       new MixedRouteSDK([pool_0_1, pool_1_WETH, pair_2_WETH], token0, WETH),
      //       amountIn,
      //       TradeType.EXACT_INPUT
      //     )
      //     const mixedRouteTrade2 = MixedRouteTrade.fromRoute(
      //       new MixedRouteSDK([pair_0_1, pair_1_2, pool_2_WETH], token0, WETH),
      //       amountIn,
      //       TradeType.EXACT_INPUT
      //     )

      //     it('generates correct calldata', async () => {
      //       const trades = [await mixedRouteTrade1, await mixedRouteTrade2]
      //       const { calls, value } = await SwapRouter.swapCallParameters(trades, {
      //         slippageTolerance,
      //         recipient,
      //         deadlineOrPreviousBlockhash: deadline,
      //       })
      //       expect(calls).toEqual(expectedCalldata)
      //       expect(value).toBe('0x00')
      //     })
      //   })
    })

    describe('ETH input', () => {
      describe('single-hop exact input (v2 + v3)', () => {
        describe('different trade configurations result in identical calldata', () => {
          const expectedCalldata =
            '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000e4472b43f300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000062000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e404e45aaf000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000bb8000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000061000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
          const amountIn = CurrencyAmount.fromRawAmount(ETHER, JSBI.BigInt(100))

          const v3Trade = V3Trade.fromRoute(new V3Route([pool_1_WETH], ETHER, token1), amountIn, TradeType.EXACT_INPUT)

          it('array of trades', async () => {
            const trades = [await v3Trade]
            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0xc8')
          })

          // it('mixedRoute produces the same calldata when swapped in', async () => {
          //   const trades = [v2Trade, await mixedRouteTrade]
          //   const { calls, value } = await SwapRouter.swapCallParameters(trades, {
          //     slippageTolerance,
          //     recipient,
          //     deadlineOrPreviousBlockhash: deadline,
          //   })
          //   expect(calls).toEqual(expectedCalldata)
          //   expect(value).toBe('0xc8')
          // })

          it('meta-trade', async () => {
            const trades = await Trade.fromRoutes(
              [
                {
                  routev3: (await v3Trade).swaps[0].route,
                  amount: amountIn,
                },
              ],
              TradeType.EXACT_INPUT
            )

            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0xc8')
          })

          // it('meta-trade with mixedRoute', async () => {
          //   const trades = await Trade.fromRoutes(
          //     [
          //       {
          //         routev2: v2Trade.route,
          //         amount: amountIn,
          //       },
          //     ],
          //     [],
          //     TradeType.EXACT_INPUT,
          //     [
          //       {
          //         mixedRoute: (await mixedRouteTrade).swaps[0].route,
          //         amount: amountIn,
          //       },
          //     ]
          //   )

          //   const { calls, value } = await SwapRouter.swapCallParameters(trades, {
          //     slippageTolerance,
          //     recipient,
          //     deadlineOrPreviousBlockhash: deadline,
          //   })
          //   expect(calls).toEqual(expectedCalldata)
          //   expect(value).toBe('0xc8')
          // })
        })
      })

      describe('single-hop exact output (v2 + v3)', () => {
        describe('different trade configurations result in identical calldata', () => {
          const expectedCalldata =
            '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000000e442712a6700000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000066000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e45023b4df000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000bb8000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000067000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000412210e8a00000000000000000000000000000000000000000000000000000000'
          const amountOut = CurrencyAmount.fromRawAmount(token1, JSBI.BigInt(100))

          const v3Trade = V3Trade.fromRoute(
            new V3Route([pool_1_WETH], ETHER, token1),
            amountOut,
            TradeType.EXACT_OUTPUT
          )

          it('array of trades', async () => {
            const trades = [await v3Trade]
            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0xcd')
          })

          it('meta-trade', async () => {
            const trades = await Trade.fromRoutes(
              [
                {
                  routev3: (await v3Trade).swaps[0].route,
                  amount: amountOut,
                },
              ],
              TradeType.EXACT_OUTPUT
            )

            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0xcd')
          })
        })
      })

      describe('multi-hop exact input (v2 + v3)', () => {
        describe('different trade configurations result in identical calldata', () => {
          const expectedCalldata =
            '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000104472b43f300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000061000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000124b858183f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000005f0000000000000000000000000000000000000000000000000000000000000042c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb80000000000000000000000000000000000000002000bb8000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
          const amountIn = CurrencyAmount.fromRawAmount(ETHER, JSBI.BigInt(100))

          const v3Trade = V3Trade.fromRoute(
            new V3Route([pool_1_WETH, pool_0_1], ETHER, token0),
            amountIn,
            TradeType.EXACT_INPUT
          )

          it('array of trades', async () => {
            const trades = [await v3Trade]
            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0xc8')
          })

          // it('mixedRoutes in array produce same calldata', async () => {
          //   const trades = [await mixedRouteTrade, await v3Trade]
          //   const { calls, value } = await SwapRouter.swapCallParameters(trades, {
          //     slippageTolerance,
          //     recipient,
          //     deadlineOrPreviousBlockhash: deadline,
          //   })
          //   expect(calls).toEqual(expectedCalldata)
          //   expect(value).toBe('0xc8')
          // })

          it('meta-trade', async () => {
            const trades = await Trade.fromRoutes(
              [
                {
                  routev3: (await v3Trade).swaps[0].route,
                  amount: amountIn,
                },
              ],
              TradeType.EXACT_INPUT
            )

            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0xc8')
          })

          // it('meta-trade with mixedRoutes produces calldata in different order but same content', async () => {
          //   /// @dev since we order the calldata in the array in a particular way (v2, v3, mixedRoute) the ordering will be different, but the encoded swap data will be the same
          //   /// Additionally, since we aren't sharing balances across trades order should not matter
          //   const expectedCalldata =
          //     '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000124b858183f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000005f0000000000000000000000000000000000000000000000000000000000000042c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb80000000000000000000000000000000000000002000bb80000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000104472b43f300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000061000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000'
          //   const trades = await Trade.fromRoutes(
          //     [],
          //     [
          //       {
          //         routev3: (await v3Trade).swaps[0].route,
          //         amount: amountIn,
          //       },
          //     ],
          //     TradeType.EXACT_INPUT,
          //     [
          //       {
          //         mixedRoute: (await mixedRouteTrade).swaps[0].route,
          //         amount: amountIn,
          //       },
          //     ]
          //   )

          //   const { calls, value } = await SwapRouter.swapCallParameters(trades, {
          //     slippageTolerance,
          //     recipient,
          //     deadlineOrPreviousBlockhash: deadline,
          //   })
          //   expect(calls).toEqual(expectedCalldata)
          //   expect(value).toBe('0xc8')
          // })
        })
      })

      describe('multi-hop exact output (v2 + v3)', () => {
        describe('different trade configurations result in identical calldata', () => {
          const expectedCalldata =
            '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010442712a6700000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000067000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012409b813460000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000006900000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000001000bb80000000000000000000000000000000000000002000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000412210e8a00000000000000000000000000000000000000000000000000000000'
          const amountOut = CurrencyAmount.fromRawAmount(token0, JSBI.BigInt(100))

          const v3Trade = V3Trade.fromRoute(
            new V3Route([pool_1_WETH, pool_0_1], ETHER, token0),
            amountOut,
            TradeType.EXACT_OUTPUT
          )

          it('array of trades', async () => {
            const trades = [await v3Trade]
            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0xd0')
          })

          it('meta-trade', async () => {
            const trades = await Trade.fromRoutes(
              [
                {
                  routev3: (await v3Trade).swaps[0].route,
                  amount: amountOut,
                },
              ],
              TradeType.EXACT_OUTPUT
            )

            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0xd0')
          })
        })
      })

      describe('high price impact with ETH input to result in refundETH being appended to calldata', () => {
        const expectedCalldata =
          '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000000e4472b43f300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000062000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e404e45aaf000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000bb8000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000412210e8a00000000000000000000000000000000000000000000000000000000'
        const amountIn = CurrencyAmount.fromRawAmount(ETHER, JSBI.BigInt(100))
        const pool_1_WETH_slippage = makePool(token1, WETH, 100)
        const REFUND_ETH_FUNCTION_SIG = /12210e8a/

        const v3Trade = V3Trade.fromRoute(
          new V3Route([pool_1_WETH_slippage], ETHER, token1),
          amountIn,
          TradeType.EXACT_INPUT
        )

        it('array of trades', async () => {
          const trades = [await v3Trade]
          const { calls, value } = await SwapRouter.swapCallParameters(trades, {
            slippageTolerance,
            recipient,
            deadlineOrPreviousBlockhash: deadline,
          })
          expect(calls).toEqual(expectedCalldata)
          expect(calls).toMatch(REFUND_ETH_FUNCTION_SIG)
          expect(value).toBe('0xc8')
        })
      })

      describe('high price impact with ERCO20 input does not result in refundETH call', () => {
        const expectedCalldata =
          '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000e4472b43f3000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e404e45aaf0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000bb8000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
        const amountIn = CurrencyAmount.fromRawAmount(token1, JSBI.BigInt(100))
        const pool_1_WETH_slippage = makePool(token1, WETH, 100)
        const REFUND_ETH_FUNCTION_SIG = /12210e8a/

        const v3Trade = V3Trade.fromRoute(
          new V3Route([pool_1_WETH_slippage], token1, WETH),
          amountIn,
          TradeType.EXACT_INPUT
        )

        it('array of trades', async () => {
          const trades = [await v3Trade]
          const { calls, value } = await SwapRouter.swapCallParameters(trades, {
            slippageTolerance,
            recipient,
            deadlineOrPreviousBlockhash: deadline,
          })
          expect(calls).toEqual(expectedCalldata)
          expect(calls).not.toMatch(REFUND_ETH_FUNCTION_SIG)
          expect(value).toBe('0x00')
        })
      })
    })

    describe('ETH output', () => {
      describe('single-hop exact input (v2 + v3)', () => {
        describe('different trade configurations result in identical calldata', () => {
          const expectedCalldata =
            '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000000e4472b43f3000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e404e45aaf0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000bb8000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000061000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004449404b7c00000000000000000000000000000000000000000000000000000000000000c3000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000'
          const amountIn = CurrencyAmount.fromRawAmount(token1, JSBI.BigInt(100))

          const v3Trade = V3Trade.fromRoute(new V3Route([pool_1_WETH], token1, ETHER), amountIn, TradeType.EXACT_INPUT)

          it('array of trades', async () => {
            const trades = [await v3Trade]
            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0x00')
          })

          // it('array of trades with mixedRoute produces same calldata', async () => {
          //   const trades = [v2Trade, await mixedRouteTrade]
          //   const { calls, value } = await SwapRouter.swapCallParameters(trades, {
          //     slippageTolerance,
          //     recipient,
          //     deadlineOrPreviousBlockhash: deadline,
          //   })
          //   expect(calls).toEqual(expectedCalldata)
          //   expect(value).toBe('0x00')
          // })

          it('meta-trade', async () => {
            const trades = await Trade.fromRoutes(
              [
                {
                  routev3: (await v3Trade).swaps[0].route,
                  amount: amountIn,
                },
              ],
              TradeType.EXACT_INPUT
            )

            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0x00')
          })

          // it('meta-trade with mixedRoute produces same calldata', async () => {
          //   const trades = await Trade.fromRoutes(
          //     [
          //       {
          //         routev2: v2Trade.route,
          //         amount: amountIn,
          //       },
          //     ],
          //     [],
          //     TradeType.EXACT_INPUT,
          //     [
          //       {
          //         mixedRoute: (await mixedRouteTrade).swaps[0].route,
          //         amount: amountIn,
          //       },
          //     ]
          //   )

          //   const { calls, value } = await SwapRouter.swapCallParameters(trades, {
          //     slippageTolerance,
          //     recipient,
          //     deadlineOrPreviousBlockhash: deadline,
          //   })
          //   expect(calls).toEqual(expectedCalldata)
          //   expect(value).toBe('0x00')
          // })
        })
      })

      describe('single-hop exact output (v2 + v3)', () => {
        describe('different trade configurations result in identical calldata', () => {
          const expectedCalldata =
            '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000000e442712a67000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000660000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e45023b4df0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000bb8000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000067000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004449404b7c00000000000000000000000000000000000000000000000000000000000000c8000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000'
          const amountOut = CurrencyAmount.fromRawAmount(ETHER, JSBI.BigInt(100))

          const v3Trade = V3Trade.fromRoute(
            new V3Route([pool_1_WETH], token1, ETHER),
            amountOut,
            TradeType.EXACT_OUTPUT
          )

          it('array of trades', async () => {
            const trades = [await v3Trade]
            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0x00')
          })

          it('meta-trade', async () => {
            const trades = await Trade.fromRoutes(
              [
                {
                  routev3: (await v3Trade).swaps[0].route,
                  amount: amountOut,
                },
              ],
              TradeType.EXACT_OUTPUT
            )

            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0x00')
          })
        })
      })

      describe('multi-hop exact input (v2 + v3)', () => {
        describe('different trade configurations result in identical calldata', () => {
          const expectedCalldata =
            '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000104472b43f30000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000006100000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000124b858183f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000005f00000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000001000bb80000000000000000000000000000000000000002000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004449404b7c00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000'
          const amountIn = CurrencyAmount.fromRawAmount(token0, JSBI.BigInt(100))

          const v3Trade = V3Trade.fromRoute(
            new V3Route([pool_0_1, pool_1_WETH], token0, ETHER),
            amountIn,
            TradeType.EXACT_INPUT
          )

          it('array of trades', async () => {
            const trades = [await v3Trade]
            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0x00')
          })

          // it('array of trades with mixedRoute produces same calldata', async () => {
          //   const trades = [await mixedRouteTrade, await v3Trade]
          //   const { calls, value } = await SwapRouter.swapCallParameters(trades, {
          //     slippageTolerance,
          //     recipient,
          //     deadlineOrPreviousBlockhash: deadline,
          //   })
          //   expect(calls).toEqual(expectedCalldata)
          //   expect(value).toBe('0x00')
          // })

          it('meta-trade', async () => {
            const trades = await Trade.fromRoutes(
              [
                {
                  routev3: (await v3Trade).swaps[0].route,
                  amount: amountIn,
                },
              ],
              TradeType.EXACT_INPUT
            )

            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0x00')
          })

          // it('meta-trade with mixedRoute produces same calldata but in different order', async () => {
          //   const expectedCalldata =
          //     '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000124b858183f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000005f00000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000001000bb80000000000000000000000000000000000000002000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000104472b43f30000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000006100000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004449404b7c00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000'
          //   const trades = await Trade.fromRoutes(
          //     [],
          //     [
          //       {
          //         routev3: (await v3Trade).swaps[0].route,
          //         amount: amountIn,
          //       },
          //     ],
          //     TradeType.EXACT_INPUT,
          //     [
          //       {
          //         mixedRoute: (await mixedRouteTrade).swaps[0].route,
          //         amount: amountIn,
          //       },
          //     ]
          //   )

          //   const { calls, value } = await SwapRouter.swapCallParameters(trades, {
          //     slippageTolerance,
          //     recipient,
          //     deadlineOrPreviousBlockhash: deadline,
          //   })
          //   expect(calls).toEqual(expectedCalldata)
          //   expect(value).toBe('0x00')
          // })
        })
      })

      describe('multi-hop exact output (v2 + v3)', () => {
        describe('different trade configurations result in identical calldata', () => {
          const expectedCalldata =
            '0x5ae401dc000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010442712a670000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000006700000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012409b81346000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000690000000000000000000000000000000000000000000000000000000000000042c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb80000000000000000000000000000000000000002000bb8000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004449404b7c00000000000000000000000000000000000000000000000000000000000000c8000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000'
          const amountOut = CurrencyAmount.fromRawAmount(ETHER, JSBI.BigInt(100))

          const v3Trade = V3Trade.fromRoute(
            new V3Route([pool_0_1, pool_1_WETH], token0, ETHER),
            amountOut,
            TradeType.EXACT_OUTPUT
          )

          it('array of trades', async () => {
            const trades = [await v3Trade]
            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0x00')
          })

          it('meta-trade', async () => {
            const trades = await Trade.fromRoutes(
              [
                {
                  routev3: (await v3Trade).swaps[0].route,
                  amount: amountOut,
                },
              ],
              TradeType.EXACT_OUTPUT
            )

            const { calls, value } = await SwapRouter.swapCallParameters(trades, {
              slippageTolerance,
              recipient,
              deadlineOrPreviousBlockhash: deadline,
            })
            expect(calls).toEqual(expectedCalldata)
            expect(value).toBe('0x00')
          })
        })
      })
    })
  })
})

const encodeTrade = (
  tradeName: string,
  token0: Token,
  token1: Token,
  pool: Pool,
  recipient: string,
  primaryAmount: BigintIsh,
  secondaryAmount: BigintIsh,
  sqrtPrice?: BigintIsh
) => {
  const sigHash = SwapRouter.INTERFACE.getSighash(tradeName)
  const paddedToken0Address = token0.address.toLowerCase().substring(2).padStart(64, '0')
  const paddedToken1Address = token1.address.toLowerCase().substring(2).padStart(64, '0')
  const paddedFee = pool.fee.toString(16).padStart(64, '0')
  const paddedRecipient = recipient.substring(2).padStart(64, '0')

  // exactOutput/exactInput use this as output/input respectively
  const paddedPrimaryAmount = toHex(primaryAmount).substring(2).padStart(64, '0')

  // the remaining amount is used as secondary
  const paddedSecondaryAmount = toHex(secondaryAmount).substring(2).padStart(64, '0')
  const paddedSqrtPrice = toHex(sqrtPrice ?? 0)
    .substring(2)
    .padStart(64, '0')

  return `${sigHash}${paddedToken0Address}${paddedToken1Address}${paddedFee}${paddedRecipient}${paddedPrimaryAmount}${paddedSecondaryAmount}${paddedSqrtPrice}`
}

const encodeMultiHopTrade = (
  tradeType: TradeType,
  route: Route<Currency, Currency>,
  recipient: string,
  primaryAmount: BigintIsh,
  minimumSecondaryAmount: BigintIsh
) => {
  const sigHash = SwapRouter.INTERFACE.getSighash(tradeType === TradeType.EXACT_OUTPUT ? 'exactOutput' : 'exactInput')
  const paddedPath = encodeRouteToPath(route, tradeType === TradeType.EXACT_OUTPUT)
    .substring(2)
    .padEnd(192, '0')
  const paddedPathOffset =
    '00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000080'
  const paddedPathLength = '0000000000000000000000000000000000000000000000000000000000000042'
  const paddedRecipient = recipient.substring(2).padStart(64, '0')

  // the remaining amount is used as secondary
  const paddedPrimaryAmount = toHex(primaryAmount).substring(2).padStart(64, '0')
  const paddedSecondaryAmount = toHex(minimumSecondaryAmount).substring(2).padStart(64, '0')

  return `${sigHash}${paddedPathOffset}${paddedRecipient}${paddedPrimaryAmount}${paddedSecondaryAmount}${paddedPathLength}${paddedPath}`
}
